The design of the InstrumentedSet class is enabled by the existence of the Set interface, which captures the functionality of the HashSet class. Besides being robust, this design is extremely flexible. The InstrumentedSet class implements the Set interface and has a single constructor whose argument is also of type Set. In essence, the class transforms one Set into another, adding the instrumentation functionality. Unlike the inheritance-based approach, which works only for a single concrete class and requires a separate constructor for each supported constructor in the superclass, the wrapper class can be used to instrument any Set implementation and will work in conjunction with any preexisting constructor:{    Set<Date> s = new InstrumentedSet<Date>(new TreeSet<Date>(cmp)); Set<E> s2 = new InstrumentedSet<E>(new HashSet<E>(capacity));}.The InstrumentedSet class can even be used to temporarily instrument a set instance that has already been used without instrumentation:static void walk(Set<Dog> dogs) {InstrumentedSet<Dog> iDogs = new InstrumentedSet<Dog>(dogs); // Within this method use iDogs instead of dogs}.The InstrumentedSet class is known as a wrapper class because each InstrumentedSet instance contains (“wraps”) another Set instance. This is also known as the Decorator pattern, because the Instrumented- Set class “decorates” a set by adding instrumentation. Sometimes the combination of composition and forwarding is loosely referred to as delegation. Technically it’s not delegation unless the wrapper object passes itself to the wrapped object.